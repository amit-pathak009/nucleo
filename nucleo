#!/bin/bash

# =========================
# Self Update & Install
# =========================

SCRIPT_NAME="nucleo"
REPO_URL="https://github.com/amit-pathak009/nucleo"
INSTALL_PATH="/usr/local/bin/${SCRIPT_NAME}"

# Absolute path of current script
SCRIPT_PATH="$(realpath "$0")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"

self_update() {
    if [[ -d "$SCRIPT_DIR/.git" ]]; then
        echo "[*] Checking for updates..."
        git -C "$SCRIPT_DIR" fetch --quiet

        LOCAL_HASH=$(git -C "$SCRIPT_DIR" rev-parse HEAD)
        REMOTE_HASH=$(git -C "$SCRIPT_DIR" rev-parse @{u})

        if [[ "$LOCAL_HASH" != "$REMOTE_HASH" ]]; then
            echo "[+] Update found. Pulling latest version..."
            git -C "$SCRIPT_DIR" pull --rebase
            echo "[+] Update complete. Re-running script..."
            exec "$SCRIPT_PATH" "$@"
        else
            echo "[✓] Already up to date."
        fi
    else
        echo "[!] Not a git repository. Skipping update check."
    fi
}

self_install() {
    if [[ ! -x "$INSTALL_PATH" ]]; then
        echo "[*] Installing to $INSTALL_PATH"
        sudo cp "$SCRIPT_PATH" "$INSTALL_PATH"
        sudo chmod +x "$INSTALL_PATH"
        echo "[✓] Installed. You can now run: ${SCRIPT_NAME}"
    fi
}

# Run update check
self_update "$@"

# Install globally
self_install

# =========================
# Auto-Adaptive Nuclei Scanner (Optimized Version)
# =========================

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'

# =========================
# Defaults
# =========================
SUBS_FILE=""
RUN_HTTPX=false
HTTPX_FILE=""
TEMPLATES_DIR="${HOME}/nuclei-templates"
TEMPLATE_TYPE="all"
STATUS_CODES="200|301|302|307|308|401|403|400|500"
SCAN_DIR="${HOME}/scan_results"
VERBOSE=false
LOG_FILE=""
MAX_RETRIES=2

# =========================
# Usage
# =========================
usage() {
  echo -e "${YELLOW}Usage:${NC} $0 -f subs.txt [-x run|httpx.txt] [-v] [-d scan_dir] [-l log.txt]"
  exit 1
}

# =========================
# Parse options
# =========================
while getopts "f:x:vd:l:" opt; do
  case "$opt" in
    f) SUBS_FILE="$OPTARG" ;;
    x) RUN_HTTPX=true; HTTPX_FILE="$OPTARG" ;;
    v) VERBOSE=true ;;
    d) SCAN_DIR="$OPTARG" ;;
    l) LOG_FILE="$OPTARG" ;;
    *) usage ;;
  esac
done

[[ -z "$SUBS_FILE" || ! -f "$SUBS_FILE" ]] && echo -e "${RED}[!] Subdomain file missing${NC}" && usage

mkdir -p "$SCAN_DIR"
[[ -n "$LOG_FILE" ]] && LOG_FILE="$SCAN_DIR/$LOG_FILE"

# =========================
# Cleanup on Ctrl+C
# =========================
cleanup() {
    echo -e "${RED}\n[!] Interrupted! Killing all background jobs...${NC}"
    jobs -p | xargs -r kill
    exit 1
}
trap cleanup SIGINT

# =========================
# Robust Auto System Detection
# =========================
# CPU threads
if command -v nproc >/dev/null 2>&1; then
    CPU_THREADS=$(nproc)
elif [[ -f /proc/cpuinfo ]]; then
    CPU_THREADS=$(grep -c '^processor' /proc/cpuinfo)
else
    CPU_THREADS=2
fi

# Available RAM in MB
if command -v free >/dev/null 2>&1; then
    MEM_AVAILABLE_MB=$(free -m | awk '/Mem:/ {print $7}')
elif [[ -f /proc/meminfo ]]; then
    MEM_AVAILABLE_KB=$(awk '/MemAvailable:/ {print $2}' /proc/meminfo)
    MEM_AVAILABLE_MB=$((MEM_AVAILABLE_KB / 1024))
else
    MEM_AVAILABLE_MB=2048
fi

# Disk free space in GB
if command -v df >/dev/null 2>&1; then
    DISK_FREE_GB=$(df -BG "$SCAN_DIR" 2>/dev/null | awk 'NR==2 {gsub("G","",$4); print $4}')
    [[ -z "$DISK_FREE_GB" ]] && DISK_FREE_GB=10
else
    DISK_FREE_GB=10
fi

# GPU detection
if command -v nvidia-smi >/dev/null 2>&1; then
    GPU_NAME=$(nvidia-smi --query-gpu=name --format=csv,noheader | head -n1)
else
    GPU_NAME="None"
fi

# =========================
# Safety Checks
# =========================
if [[ "$DISK_FREE_GB" -lt 5 ]]; then
  echo -e "${RED}[!] Not enough disk space (${DISK_FREE_GB}GB). Need at least 5GB.${NC}"
  exit 1
fi

# =========================
# Adaptive Tuning
# =========================
# Chunk size (adjusted dynamically)
if (( MEM_AVAILABLE_MB < 2000 )); then
  CHUNK_SIZE=300
elif (( MEM_AVAILABLE_MB < 4000 )); then
  CHUNK_SIZE=600
elif (( MEM_AVAILABLE_MB < 8000 )); then
  CHUNK_SIZE=1200
else
  CHUNK_SIZE=2000
fi

# Concurrency & rate
CONCURRENCY=$CPU_THREADS
(( CONCURRENCY > 12 )) && CONCURRENCY=12
RATE_LIMIT=$(( CONCURRENCY * 3 ))

# =========================
# Show detected config
# =========================
echo -e "${CYAN}=== Auto Detected System ===${NC}"
echo -e "CPU Threads   : ${GREEN}$CPU_THREADS${NC}"
echo -e "RAM Available : ${GREEN}${MEM_AVAILABLE_MB} MB${NC}"
echo -e "Disk Free     : ${GREEN}${DISK_FREE_GB} GB${NC}"
echo -e "GPU           : ${GREEN}${GPU_NAME}${NC}"
echo -e "Chunk Size    : ${GREEN}$CHUNK_SIZE${NC}"
echo -e "Concurrency   : ${GREEN}$CONCURRENCY${NC}"
echo -e "Rate Limit    : ${GREEN}$RATE_LIMIT${NC}"
echo ""

# =========================
# HTTPX
# =========================
if $RUN_HTTPX; then
  echo -e "${GREEN}[+] Running HTTPX...${NC}"
  if [[ "$HTTPX_FILE" == "run" ]]; then
    httpx -l "$SUBS_FILE" -sc -ct -title -cname -server -td -cdn -o "$SCAN_DIR/live.txt"
  else
    cp "$HTTPX_FILE" "$SCAN_DIR/live.txt"
  fi
  grep -E "$STATUS_CODES" "$SCAN_DIR/live.txt" | awk '{print $1}' > "$SCAN_DIR/live_filtered.txt"
  SUBS_FILE="$SCAN_DIR/live_filtered.txt"
fi

# =========================
# Split targets
# =========================
CHUNK_PREFIX="$SCAN_DIR/nuclei_chunk_"
OUTPUT_FILE="$SCAN_DIR/nuclei_results.txt"
rm -f "$CHUNK_PREFIX"* "$OUTPUT_FILE"

echo -e "${GREEN}[+] Splitting targets...${NC}"
split -l "$CHUNK_SIZE" "$SUBS_FILE" "$CHUNK_PREFIX"

# =========================
# Nuclei runner
# =========================
run_chunk() {
  local f="$1"
  local try=0
  while (( try <= MAX_RETRIES )); do
    if $VERBOSE && [[ -n "$LOG_FILE" ]]; then
      nuclei -l "$f" -t "$TEMPLATES_DIR" -c "$CONCURRENCY" -rate-limit "$RATE_LIMIT" -timeout 15 -o "$f.out" 2>&1 | tee -a "$LOG_FILE"
    elif $VERBOSE; then
      nuclei -l "$f" -t "$TEMPLATES_DIR" -c "$CONCURRENCY" -rate-limit "$RATE_LIMIT" -timeout 15 -o "$f.out"
    else
      nuclei -l "$f" -t "$TEMPLATES_DIR" -c "$CONCURRENCY" -rate-limit "$RATE_LIMIT" -timeout 15 -silent -o "$f.out"
    fi

    [[ -s "$f.out" ]] && break
    ((try++))
  done
}

# =========================
# Run scan (optimized parallel execution)
# =========================
echo -e "${GREEN}[+] Starting Nuclei scan...${NC}"

# Use a process pool to limit concurrency properly
pids=()
for f in "$CHUNK_PREFIX"*; do
  run_chunk "$f" &
  pids+=($!)

  # Limit concurrent jobs
  while (( $(jobs -r | wc -l) >= CONCURRENCY )); do
    sleep 1
  done
done

# Wait for all background processes
wait "${pids[@]}"

# Combine results
cat "$CHUNK_PREFIX"*.out 2>/dev/null | sort -u > "$OUTPUT_FILE"

echo -e "${CYAN}[✓] Scan completed successfully${NC}"
echo -e "${CYAN}[✓] Results: $OUTPUT_FILE${NC}"
